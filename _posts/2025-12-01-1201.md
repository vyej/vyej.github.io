---
layout: post
category: [notes]
title: docker一個neo4j
date: 2025-12-01 22:17:32
tags: [graph, neo4j, docker]
math: true
---

其實也是時隔好久了，很久沒有用neo4j了吧，說起來。看來還是躲不過吧。那就用起來唄。只是相比SQL，這個實在是有太多的要學的了吧。

還是先docker部署唄：

其實還是看的官方文檔。

	docker run \
    --restart always \
    --publish=7474:7474 --publish=7687:7687 \
    --env NEO4J_AUTH=neo4j/your_password \
    --volume=/path/to/your/data:/data \
    neo4j:2025.11.2
	
然後是加入這個Neo4j的图数据科学库：

	docker run -it --rm \
	--publish=7474:7474 --publish=7687:7687 \
	--user="$(id -u):$(id -g)" \
	--env NEO4J_AUTH=none \
	--env NEO4J_PLUGINS='["graph-data-science"]' \
	neo4j:latest

然後就瀏覽器上localhost:7474就可以登錄進去了。

不過，最重要的是導入的數據，所以需要設置`import`文件夾，然後是APOC插件的應用，docker應該是最爲簡單的：

	sudo docker run \
    --restart always \
    --publish=7474:7474 --publish=7687:7687 \
	--user="$(id -u):$(id -g)" \
	--env NEO4J_AUTH=none \
	--env NEO4J_PLUGINS='["graph-data-science"]' \
	--env NEO4J_apoc_export_file_enabled=true \
    --env NEO4J_apoc_import_file_enabled=true \
    --env NEO4J_apoc_import_file_use__neo4j__config=true \
    --env NEO4J_PLUGINS=\[\"apoc\"\] \
    --volume=$HOME/neo4j/data:/data \
    --volume=$HOME/neo4j/import:/import \
    neo4j:2025.11.2

**只是好像社區版本的neo4j的社區版本，只能一次使用一個數據庫，默認的就是neo4j了。**

------

Neo4j图数据库由三个核心实体组成：节点、关系和路径。

neo4j使用的是叫cypher的語言。“Cypher 是 Neo4j 的声明式且符合 GQL 标准的查询语言。Cypher 类似于 SQL，但针对图进行了优化。”

Cypher 提供了一种可视化匹配模式和关系的方式。它依赖于以下 ASCII 艺术风格的语法：(nodes)-[:CONNECT_TO]→(otherNodes)。圆括号用于圆形节点，-[:ARROWS]→ 用于关系。编写查询实际上就像在图中绘制数据模式。

> neo4j 的图模型由节点（nodes）和关系（relationships）组成，它们也可以拥有分配的属性（peoperties）。通过节点和关系，您可以构建强大的模式，表达简单或复杂的模式（patterns）。

	(:nodes)-[:ARE_CONNECTED_TO]->(:otherNodes)

> 使用圆括号表示 (:Nodes)，使用 -[:ARROWS]→ 表示 (:Nodes) 之间的关系。
> 节点可以通过标签（label）进行分组。它们像标签一样工作，允许您指定要查找或创建的特定实体类型。标签还有助于 Cypher 区分实体并优化查询执行。**If you do not specify a label for Cypher to filter out non-matching node categories, the query will check all of the nodes in the database. This can affect performance in very large graphs.**

- 节点变量（Node variables）： 为了在后续子句中引用匹配的数据实体，you can use node variables

Variables can be single letters or words, and should be written in lower-case. For example, if you want to bind all nodes labeled Person to the variable p, you write (p:Person). If you want to use a full word as a variable, (person:Person) works exactly the same.

	MATCH (p:Person)
	RETURN p

## Relationships（關係）

In a graph database, both nodes and relationships are first-class citizens and they have equal value. In a relational database, relationships are only implied via foreign keys and join tables.圖數據庫中，節點和關係具有相同的地位——對比在關係數據庫中，關係只能通過外鍵來連接表。

In Cypher, relationships are represented as square brackets with an optional arrow to indicate the direction (e.g. (Node1)-[]→(Node2)).

### 關係方向

**Relationships always have a direction which is indicated by an arrow.** 關係總有方向，用一個箭頭表示。
`(p:Person)-[:LIKES]->(t:Technology)`。

不能在没有方向的情况下创建关系，但可以无方向地查询它们。

### 關係類型

Relationship types categorize and add meaning to a relationship, similar to how labels group nodes together. It is considered best practice to use verbs or derivatives for the relationship type. The type describes how the nodes relate to each other. 这样，Cypher 几乎就像自然语言，其中节点是主语和宾语（名词），而关系（动词）是连接它们的动作词。

### 關係變量

变量可以像用于节点一样用于关系。一旦指定了变量，您就可以在查询中稍后使用它来引用该关系。

	MATCH (p:Person)-[r:LIKES]->(t:Technology)
	RETURN p,r,t

**记住始终在关系类型前面加上冒号。如果忘记了，并编写了诸如 (:Person)-[LIKES]→(:Technology) 这样的查询，那么 [LIKES] 将表示一个关系变量，而不是关系类型。由于没有声明关系类型，Cypher 将搜索所有类型的关系以检索查询结果。**

## 屬性（Properties）

Properties are used to store additional information and can be added both to nodes and relationships and be of a variety of data types. 

Properties are enclosed by curly brackets ({}), the key is followed by a colon, and the value is enclosed by single or double quotation marks.属性用花括号 ({}) 括起来，键后跟冒号，值用单引号或双引号括起来。


## Patterns in Cypher（Cypher 中的模式）

Graph pattern matching sits at the very core of Cypher. It is the mechanism used to navigate, describe, and extract data from a graph by applying a declarative pattern.图模式匹配是 Cypher 的核心。它是通过应用声明式模式来导航、描述和从图中提取数据的机制。

示例： `(p:Person {name: "Sally"})-[r:LIKES]->(g:Technology {type: "Graphs"})`

	   CREATE (p:Person {name: "Sally"})-[r:LIKES]->(t:Technology {type: "Graphs"})
	   MATCH (p:Person {name: "Sally"})-[r:LIKES]->(t:Technology {type: "Graphs"})
RETURN p,r,t

### Pattern variables

与节点和关系一样，也可以对模式使用变量。

variable (p):

	MATCH p = (sally:Person {name: "Sally"})-[r:LIKES]->(t:Technology {type: "Graphs"})
	RETURN p


------
 
## Cypher 与 SQL

- 共享许多相同的关键字，例如 WHERE 和 ORDER BY

- Cypher 模式灵活：Cypher 和 Neo4j 比 SQL 和关系数据库提供了更大的模式灵活性。更具体地说，Neo4j 数据库中的节点和关系不必具有特定的属性集，因为同一图中的其他节点或关系具有该属性（除非在该特定属性上创建了属性存在约束）。这意味着用户无需使用固定模式来表示数据，并且他们可以随着图的演变添加新的属性和关系。

- 查询顺序：SQL 查询以用户想要返回的内容开始，而 Cypher 查询以返回子句结束。

SQL:
	ELECT movie.name
	FROM movie
	WHERE movie.rating > 7

Cypher:
	MATCH (movie:Movie)
	WHERE movie.rating > 7
	RETURN movie.title

- Cypher 查询更简洁

	SELECT actors.name
	FROM actors
 	LEFT JOIN acted_in ON acted_in.actor_id = actors.id
	LEFT JOIN movies ON movies.id = acted_in.movie_id
	WHERE movies.title = "The Matrix"

	MATCH (actor:Actor)-[:ACTED_IN]->(movie:Movie {title: 'The Matrix'})
	RETURN actor.name

--------




